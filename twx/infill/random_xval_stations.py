'''
Created on Oct 17, 2012
Utility functions for selecting a random subset of stations for cross-validation testing
@author: jared.oyler
'''
import numpy as np
from obs_por import load_por_csv,POR_DTYPE,build_valid_por_masks
from twx.utils.ncdf_raster import ncdf_raster
from twx.db.station_data import LON,LAT,STN_ID
from twx.db.station_data import station_data_ncdb

def get_random_xval_stns(stn_da,min_por_pct,nstns_per_rgn,path_por,path_neon,path_ghcn_stn_ls,exclude_stns=np.array([])):
    '''
    
    @param stn_da: a db.station_data_ncdb object
    @param min_por_pct: % of entire period of record that a station has to have observations
    @param nstns_per_rgn: the number of random stations per neon region
    @param path_por: the path to the period of record csv file generated by obs_por.py
    @param path_neon: the path to the neon ecodomains netcdf file
    @param path_ghcn_stn_ls: the path to the list of ghcn stations.  used to select only hcn stations
    @param exclude_stns: numpy array of stn_ids that should be excluded from search
    @return list of station ids
    '''
    
    def get_hcn_dict(path_ghcn_stn_ls):
    
        afile = open(path_ghcn_stn_ls)
        hcn_dict = {}
        
        for line in afile.readlines():
            
            stn_id = "".join(["GHCN_",line[0:11].strip()])
            hcn_flg = line[76:79]
            hcn_dict[stn_id] = hcn_flg
            
        return hcn_dict
    
    
    days = stn_da.days
    
    #The min number of observations at station must have to be considered
    #for extrapolation testing
    min_obs = np.round(min_por_pct*days.size)
    
    #Load the period-of-record datafile
    por = load_por_csv(path_por)
    
    #Number of obs in period-of-record for each month and variable
    por_cols = np.array([x[0] for x in POR_DTYPE])
    cols_prcp = por_cols[30:]
    por_prcp = por[cols_prcp].view(np.int32).reshape((por.size,cols_prcp.size))
    
    #Mask stations that have the min number of observations for prcp
    mask_prcp = np.sum(por_prcp,axis=1)>=min_obs
    mask_all = mask_prcp
    
    #Load the neon ecoregion raster into memory
    neon_rast = ncdf_raster(path_neon, 'neon')
    nodata_mask = neon_rast.vals.mask
    neon_rast.vals = np.array(neon_rast.vals.data,dtype=np.float32)
    neon_rast.vals[nodata_mask] = np.nan
    neon = neon_rast.vals
    uniq_rgns = np.unique(neon[np.isfinite(neon)])

    #Extract lons, lats, and stn_ids that have min # of observations
    lons = por[LON][mask_all]
    lats = por[LAT][mask_all]
    stn_ids = por[STN_ID][mask_all]
    
    #Only use HCN stations
    hcn_mask = np.zeros(stn_ids.size,dtype=np.bool)
    hcn_dict = get_hcn_dict(path_ghcn_stn_ls)
    
    for x in np.arange(stn_ids.size):
    
        try:
            if hcn_dict[stn_ids[x]] == "HCN":
                hcn_mask[x] = True
        except KeyError:
            pass
    
    lons = lons[hcn_mask]
    lats = lats[hcn_mask]
    stn_ids = stn_ids[hcn_mask]
    
    #Determine neon region for each station
    rgns = np.zeros(lons.size)
    for x in np.arange(lons.size):
        try:
            rgns[x] = neon_rast.getDataValue(lons[x],lats[x])
        except:
            rgns[x] = np.nan
            
    #Pick a specific number of random stations for each region
    fnl_stn_ids = []
    for rgn in uniq_rgns:
        
        stn_ids_rgn = stn_ids[rgns==rgn]
        
        rndm_stnids = stn_ids_rgn[np.random.randint(0,stn_ids_rgn.size,nstns_per_rgn)]
        rndm_stnids = rndm_stnids[np.logical_not(np.in1d(rndm_stnids,exclude_stns,assume_unique=True))]
        rndm_stnids = np.unique(rndm_stnids)
        
        while rndm_stnids.size < nstns_per_rgn:
            
            temp_rndm_stnids = stn_ids_rgn[np.random.randint(0,stn_ids_rgn.size,nstns_per_rgn)]
            rndm_stnids = np.unique(np.concatenate([rndm_stnids,temp_rndm_stnids]))
            rndm_stnids = rndm_stnids[np.logical_not(np.in1d(rndm_stnids,exclude_stns,assume_unique=True))]
        
        rndm_stnids = rndm_stnids[0:nstns_per_rgn]
        
        fnl_stn_ids.extend(rndm_stnids)
    
    #Make sure fnl_stn_ids is in right order for loading observation data
    fnl_stn_ids = np.array(fnl_stn_ids)
    fnl_stn_ids = stn_da.stn_ids[np.in1d(stn_da.stn_ids, fnl_stn_ids, assume_unique=True)]
    
    return fnl_stn_ids

def build_xval_masks(stn_ids,ntrain_yrs,stn_da,varname):   
    '''
    
    @param stn_ids: stn_ids for which to build xval_masks
    @param ntrain_yrs: the number of years that should used for training data
    @param stn_da:db.station_data_ncdb object
    '''
    
    #Load observations for each station
    obs = stn_da.load_all_stn_obs_var(stn_ids,varname)[0]
    
    if len(obs.shape) == 1:
        obs.shape = (obs.shape[0],1)
    
    days = stn_da.days
    
    #The number of observations that should not be set to nan
    #and are used to build the infill model
    nmask = int(np.round(ntrain_yrs*365.25))
    
    #Build masks of the data values that should be set to nan for each station
    xval_masks = []
    
    idxs = np.arange(days.size)
    
    for x in np.arange(stn_ids.size):
        
        fin_obs = np.isfinite(obs[:,x])
        
        last_idxs = np.nonzero(fin_obs)[0][-nmask:]
        xval_mask_obs = np.logical_and(np.logical_not(np.in1d(idxs,last_idxs,assume_unique=True)),fin_obs)
        xval_masks.append(xval_mask_obs)
    
    return xval_masks


class XvalStnsTairSnotelRaws:
    
    def __init__(self,stn_da,nyrs_mod,min_por_pct,por,por_mask_tmin,por_mask_tmax):
        
        mask_sntl_raws = np.logical_or(np.char.startswith(stn_da.stn_ids, "RAWS"),
                                       np.char.startswith(stn_da.stn_ids, "SNOTEL"))
        mask_por = np.logical_and(por_mask_tmin,por_mask_tmax)
        
        #The number of observations that should not be set to nan
        #and are used to build the infill model
        nmask = int(np.round(nyrs_mod*365.25))
        
        #The min number of observations a station must have to be considered
        #for extrapolation testing
        min_obs = np.round(min_por_pct*stn_da.days.size)
        
        #Number of obs in period-of-record for each month and variable
        por_cols = np.array([x[0] for x in POR_DTYPE])
        cols_tmin = por_cols[6:18]
        cols_tmax = por_cols[18:30]
        por_tmin = por[cols_tmin].view(np.int32).reshape((por.size,cols_tmin.size))
        por_tmax = por[cols_tmax].view(np.int32).reshape((por.size,cols_tmax.size))
        
        #Mask stations that have the min number of observations for both tmin and tmax
        mask_tmin = np.sum(por_tmin,axis=1)>=min_obs
        mask_tmax = np.sum(por_tmax,axis=1)>=min_obs
        mask_min_obs = np.logical_and(mask_tmax,mask_tmin)
        
        
        mask_fnl = np.logical_and(np.logical_and(mask_sntl_raws,mask_por),mask_min_obs)
#        print np.sum(mask_fnl)
#        print stn_da.stns[mask_fnl]
        
        fnl_stn_ids = stn_da.stn_ids[mask_fnl]
        
        #Load tmin and tmax observations for each station
        tmin = stn_da.load_all_stn_obs_var(fnl_stn_ids,'tmin')[0]
        tmax = stn_da.load_all_stn_obs_var(fnl_stn_ids,'tmax')[0]
        
        #Build masks of the data values that should be set to nan for each station
        #and then set the data values to nan
        xval_masks_tmin = []
        xval_masks_tmax = []
        
        idxs = np.arange(stn_da.days.size)
        
        for x in np.arange(fnl_stn_ids.size):
            
            fin_tmin = np.isfinite(tmin[:,x])
            fin_tmax = np.isfinite(tmax[:,x])
            
            last_idxs = np.nonzero(fin_tmin)[0][-nmask:]
            #last_idxs = np.nonzero(fin_tmin)[0][0:nmask]
            xval_mask_tmin = np.logical_and(np.logical_not(np.in1d(idxs,last_idxs,assume_unique=True)),fin_tmin)
            xval_masks_tmin.append(xval_mask_tmin)
            
            last_idxs = np.nonzero(fin_tmax)[0][-nmask:]
            #last_idxs = np.nonzero(fin_tmax)[0][0:nmask]
            xval_mask_tmax = np.logical_and(np.logical_not(np.in1d(idxs,last_idxs,assume_unique=True)),fin_tmax)
            xval_masks_tmax.append(xval_mask_tmax)
        
        self.stn_ids = fnl_stn_ids
        self.xval_masks_tmin = xval_masks_tmin
        self.xval_masks_tmax = xval_masks_tmax 
            
if __name__ == '__main__':
    
    stn_da = station_data_ncdb('/projects/daymet2/station_data/all/all_1948_2012.nc')
    nyrs_mod = 5
    min_por_pct = 0.40
    
    #Load the period-of-record datafile
    por = load_por_csv('/projects/daymet2/station_data/all/all_por_1948_2012.csv')
    por_mask_tmin,por_mask_tmax = build_valid_por_masks(por)[0:2]
    
    
    rndm_stns = XvalStnsTairSnotelRaws(stn_da, nyrs_mod, min_por_pct, por, por_mask_tmin, por_mask_tmax)
